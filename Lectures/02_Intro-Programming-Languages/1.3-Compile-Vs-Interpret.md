# Compiled Vs Interpreted

Compiled languages and interpreted languages are two different approaches to executing code. Each have their own beneficial use cases explained with multiple programming language examples below. 

### Key Differences:
- Compiled languages (e.g., Go, C++), 
  - code is translated into machine code before execution
  - can make them faster and more efficient but less portable
- Interpreted languages (e.g., Python, Perl)
  - code is executed directly by an interpreter
  - can make them more portable but generally slower than compiled languages

### Compiled Languages

1. **Go (Golang):** Go is a statically typed and compiled language. When you write Go code, you need to compile it into machine code before you can run it. The Go compiler (gc) translates your Go code into an executable binary that can run on a specific platform.

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

2. **C++:** C++ is another compiled language. You write C++ code, which is then compiled into machine code by a C++ compiler (e.g., g++, clang++). The resulting binary is platform-specific.

### Interpreted Languages:

**Python:** Python is an interpreted language. In Python, the code is executed line by line by the Python interpreter. You don't need to compile Python code explicitly, allowing for portability across many operating systems naturally. Python comes default on many linux distributions because of this flexibility. 

```
print("Hello, World!")
```

**Perl:** Perl is also an interpreted language. Perl scripts are executed directly by the Perl interpreter without the need for compilation. Perl has seen less use cases over the past years with the influx of python usage but is still a great choice for many problems. 

Each approach has its advantages and use cases. Compiled languages are often preferred for performance-critical applications, while interpreted languages offer ease of development and cross-platform compatibility. Typically compiled languages require a deeper understanding of the underlying syntax and heuristics of the language as well as the various boundaries you have to be aware of. Languages like Python and Perl enable people from outside professions to be able to write code that works for their issue quickly and easily without worrying about dangling pointers and memory leaks. 

>*The code examples above show an example of this, 5 lines in Golang to Python's 1*. 

Let's go deeper into the exact differences and how they play a role in a software developers choice. 

### Compiled Languages:

1. **Translation to Machine Code:** In a compiled language, the source code is translated into machine code (binary code that can be executed directly by the computer's CPU) before it is run. This translation is done by a compiler, which generates an executable file.

2. **Optimization:** Compilers often perform various optimizations during the compilation process to improve the efficiency and performance of the resulting program. These optimizations can include code reordering, dead code elimination, and inline function expansion.

3. **Platform Dependency:** The executable generated by a compiler is often specific to the target platform (e.g., Windows, Linux, macOS). This means that you may need to recompile the code for each platform you want to run it on.

4. **Execution Speed:** Compiled languages tend to have faster execution speeds compared to interpreted languages because the code is already in machine code form. This makes them suitable for performance-critical applications.

`C++`, `Rust`, `Fortran` and of course `Go` are some more examples of compiled languages.

### Interpreted Languages

1. **Direct Execution:** In an interpreted language, the source code is executed directly by an interpreter. The interpreter reads the code line by line and performs the necessary actions as it encounters each instruction.

2. **No Compilation Step:** Unlike compiled languages, there is no separate compilation step. You write the code and then run it without generating an intermediate machine code.

3. **Platform Independence:** Interpreted languages are often more platform-independent. You can run the same code on different platforms as long as there's an interpreter available for that platform.

4. **Slower Execution:** Interpreted languages tend to have slower execution speeds compared to compiled languages because the code is analyzed and executed at runtime. However, this performance difference may not be significant for many applications.

`JavaScript`, `Ruby`, `Python` and `PHP` are some more examples of interpreted languages.

### Key Metrics 
- **Execution Method:** Compiled languages convert code to machine code before running, while interpreted languages execute code line by line.
- **Portability:** Interpreted languages are generally more portable since they don't generate platform-specific executables.
- **Development Speed:** Interpreted languages often have quicker development cycles as there's no need for compilation and maintenance of system resources.
- **Performance:** Compiled languages typically offer better performance due to precompiled machine code, while interpreted languages are often slower because of the interpretation overhead.
- **Debugging:** Debugging in interpreted languages can be more straightforward because you can catch and fix errors at runtime. Remember from the syntax vs semantics lecture that a compiled language will still compile with semantics errors and not always throw the best errors for a developer to be able to trace it to the cause. Interpreted languages will not run with semantic errors and will usually highlight the line where the error was raised. 

### What about both Hybrids

- Java
- C#
- Some Python Interpreters

`Java` and `C#`, use a combination of compilation and interpretation. They compile source code into an intermediate bytecode, which is then executed by a virtual machine (e.g. Java Virtual Machine or C#'s DotNet Framework). This approach offers a balance between portability and performance. 

And then there is `JIT` (Just In Time) compilation which attempts to speed up performance by having portions of the program already converted to byte code. There is a lot involved in this and is mostly used for numerically heavy libraries. 
