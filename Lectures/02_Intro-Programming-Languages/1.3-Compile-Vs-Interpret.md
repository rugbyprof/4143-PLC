# Compiled Vs Interpreted

Compiled languages and interpreted languages are two different approaches to executing code. Each have their own beneficial use cases explained with multiple programming language examples below. 

<center><img src="https://images2.imgbox.com/b1/f8/vzIg44Zx_o.png" width="400"></center>

### Key Differences:
- Compiled languages (e.g., Go, C++), 
  - code is translated into machine code before execution
  - can make them faster and more efficient but less portable
- Interpreted languages (e.g., Python, Perl)
  - code is executed directly by an interpreter
  - can make them more portable but generally slower than compiled languages

### Compiled Languages

1. **Go (Golang):** Go is a statically typed and compiled language. When you write Go code, you need to compile it into machine code before you can run it. The Go compiler (gc) translates your Go code into an executable binary that can run on a specific platform.

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, World!")
}
```

2. **C++:** C++ is another compiled language. You write C++ code, which is then compiled into machine code by a C++ compiler (e.g., g++, clang++). The resulting binary is platform-specific.

### Interpreted Languages:

**Python:** Python is an interpreted language. In Python, the code is executed line by line by the Python interpreter. You don't need to compile Python code explicitly, allowing for portability across many operating systems naturally. Python comes default on many linux distributions because of this flexibility. 

```
print("Hello, World!")
```

>*The code examples above show an example of this, 5 lines in Golang to Python's 1*. 

**Perl:** Perl is also an interpreted language. Perl scripts are executed directly by the Perl interpreter without the need for compilation. Perl has seen less use cases over the past years with the influx of python usage but is still a great choice for many problems. 

Each approach has its advantages and use cases. Compiled languages are often preferred for performance-critical applications, while interpreted languages offer ease of development and cross-platform compatibility. Typically compiled languages require a deeper understanding of the underlying syntax and heuristics of the language as well as the various boundaries you have to be aware of. Languages like Python and Perl enable people from outside professions to be able to write code that works for their issue quickly and easily without worrying about dangling pointers and memory leaks. 



Let's go deeper into the exact differences and how they play a role in a software developers choice. 

### Compiled Languages:

1. **Translation to Machine Code:** In a compiled language, the source code is translated into machine code (binary code that can be executed directly by the computer's CPU) before it is run. This translation is done by a compiler, which generates an executable file.

2. **Optimization:** Compilers often perform various optimizations during the compilation process to improve the efficiency and performance of the resulting program. These optimizations can include code reordering, dead code elimination, and inline function expansion.

3. **Platform Dependency:** The executable generated by a compiler is often specific to the target platform (e.g., Windows, Linux, macOS). This means that you may need to recompile the code for each platform you want to run it on.

4. **Execution Speed:** Compiled languages tend to have faster execution speeds compared to interpreted languages because the code is already in machine code form. This makes them suitable for performance-critical applications.

`C++`, `Rust`, `Fortran` and of course `Go` are some more examples of compiled languages.

### Interpreted Languages

1. **Direct Execution:** In an interpreted language, the source code is executed directly by an interpreter. The interpreter reads the code line by line and performs the necessary actions as it encounters each instruction.

2. **No Compilation Step:** Unlike compiled languages, there is no separate compilation step. You write the code and then run it without generating an intermediate machine code.

3. **Platform Independence:** Interpreted languages are often more platform-independent. You can run the same code on different platforms as long as there's an interpreter available for that platform.

4. **Slower Execution:** Interpreted languages tend to have slower execution speeds compared to compiled languages because the code is analyzed and executed at runtime. However, this performance difference may not be significant for many applications.

`JavaScript`, `Ruby`, `Python` and `PHP` are some more examples of interpreted languages.

### Key Metrics 
- **Execution Method:** Compiled languages convert code to machine code before running, while interpreted languages execute code line by line.
- **Portability:** Interpreted languages are generally more portable since they don't generate platform-specific executables.
- **Development Speed:** Interpreted languages often have quicker development cycles as there's no need for compilation and maintenance of system resources.
- **Performance:** Compiled languages typically offer better performance due to precompiled machine code, while interpreted languages are often slower because of the interpretation overhead.
- **Debugging:** Debugging in interpreted languages can be more straightforward because you can catch and fix errors at runtime. Remember from the syntax vs semantics lecture that a compiled language will still compile with semantics errors and not always throw the best errors for a developer to be able to trace it to the cause. Interpreted languages will not run with semantic errors and will usually highlight the line where the error was raised. 

### Summary of Compiled Vs Interpreted
<center><img src="https://images2.imgbox.com/64/29/5ymtNnRQ_o.jpg" width="500"></center>


## Combination

- Source code gets compiled into byte code.
- The byte code then runs on a "virtual machine" which is typically a software based interpreter.
- The byte code can be run on any platform without "recompiling" since the "virtual machine" is already configured for a specific architecture.


<center><img src="https://images2.imgbox.com/bd/66/QpSZI7ol_o.png" width="400"></center>

- Two major virtual machines are: 
  - Java Virtual Machine (JVM) used by Java (obviously)
  - Common Language Runtime (CLR) used by mainly C#

#### Java and C#

- The JVM and CLR are designed for performance and can use Just-In-Time (JIT) compilation, which compiles bytecode to native machine code at runtime, leading to faster execution. 

- The JVM and CLR are designed to support multiple languages. For instance, the JVM supports Java, Scala, Kotlin, and others, while the CLR supports C#, F#, VB.NET, and more. 

- Both the JVM and CLR have extensive ecosystems and are part of larger platform offerings (Java Platform and .NET respectively), with a wide array of tools for performance optimization, monitoring, and enterprise-grade deployments.

#### Python

Python also uses a virtual machine, but it's quite different from the Java Virtual Machine (JVM) or the Common Language Runtime (CLR) used by C#.

- Python's standard implementation is CPython, which compiles Python code into bytecode. This bytecode is a low-level set of instructions that is then executed by the Python Virtual Machine (PVM). The PVM is an interpreter that runs the bytecode. This is somewhat similar to how Java compiles code into bytecode that is run on the JVM, but there are some differences, mainly in performance and support for other languages and ecosystems as mentioned above.

- CPython's PVM doesn't have JIT compilation (by default) and is generally slower.
- The PVM is primarily designed for Python, though it can support other languages through tools like Jython (Python on the JVM) or IronPython (Python on the CLR).
- Python's ecosystem is more focused on the language itself and its libraries, though there are tools for performance optimization and monitoring.

However, In addition to CPython, there are other Python implementations that utilize different virtual machines:

- **PyPy:** An alternative Python implementation that includes a JIT compiler, making it much faster than CPython for many workloads.
- **Jython:** A Python implementation for the Java platform, which compiles Python code to Java bytecode to be executed by the JVM.
- **IronPython:** A Python implementation for the .NET framework, which compiles Python code to .NET Intermediate Language (IL) to be executed by the CLR.

Each of these implementations has its own use cases and advantages, depending on the requirements of the project and the existing tech stack.
